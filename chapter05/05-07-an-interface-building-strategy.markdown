# 5.7 接口创建策略

本节描述使用SWIG创建接口文件的通用方法。语言特定的部分请参考后面的章节。

## 5.7.1 为SWIG准备C程序

SWIG不需要修改你的C代码，但是如果你塞给他一组原始的C语言头文件或源代码，结果可能不像你预期的那样工作——事实上，结果可能很糟糕。下面是当包装C程序成接口时，你需要遵循的步骤：

+ 标示出你要包装的函数。一个C程序中，可能不必要访问所有的功能——因此，事先规划能大大简化脚本语言的接口。C的头文件时决定包装什么功能的很好起点。
+ 创建一个新的接口文件，给脚本语言描述你的接口。
+ 拷贝合适的声明到接口文件中，或使用SWIG的`%include`指令处理C头或源文件。
+ 确保接口文件中的所有表示都使用ANSI C/C++语法。
+ 确保接口文件中包含素所有必要的`typedef`声明和类型信息。特别是，要确保类型信息以C/C++编译器要求的合适的顺序书写。更重要的是，在使用类型前一定要定义它！如果类型信息确实需要而你又没有提供的话，C编译器会告诉你的，而SWIG却不会警告或提示错误，因为它被设计成无需全的类型信息也可以工作。但是，如果类型信息没有正确指定，包装可能不是最优的，并且可能导致不能编译的C/C++代码。
+ 如果你的程序有`main()`函数，你需要重命名它（接着往下看）。
+ 运行SWIG并编译。

尽管这些看起来挺复杂的，但当你真的使用起来后会发现其实挺简单的。

创建接口的过程中，SWIG可能或遇到语法错误或其他问题。处理这些问题的最好方式是，简单拷贝这些代码到独立的接口文件中，然后编辑它。不管怎样，SWIG的开发者们已经尽了很大努力的去改进SWIG解释器了——如果发现问题，你应该报告解释错误到[swig-devel mailing list](http://www.swig.org/mail.html)或[SWIG bug tracker](http://www.swig.org/bugs.html)。

## 5.7.2 SWIG接口文件

使用SWIG最好的方式生成一个独立的接口文件。假设你有如下的C代码：

```c
/* File : header.h */
#include <stdio.h>
#include <math.h>
extern int foo(double);
extern double bar(int, int);
extern void dump(FILE *f);
```

针对这个头文件的典型SWIG接口文件可能长成下面这样：

```c
/* File : interface.i */
%module mymodule
%{
#include "header.h"
%}
extern int foo(double);
extern double bar(int, int);
extern void dump(FILE *f);
```

当然，这种情况下，我们的头文件比较简单，可以在接口文件中用另外一种更简单的方式：

```c
/* File : interface.i */
%module mymodule
%{
#include "header.h"
%}
%include "header.h"
```

这种方法的主要优点就是将来头文件改变后，可以减少对接口文件的维护。在一些非常复杂的项目中，一个接口文件包含了大量的`%include`指令和`#inclue`语句，这是降低维护成本的一种非常普遍的设计方式。

## 5.7.3 为什么要使用独立的接口文件呢？

尽管SWIG可以解释多数的头文件，但通常的做法是写一个独立的.i接口文件，用于定义一个包或模块的接口。有几个原因支持这么去做：

+ 很好有必要访问一个大的软件中的每个独立功能。多数的C函数可能在脚本环境中根本就没什么用处。因此，为什么还要去包装它们呢？
+ 独立的接口文件可以提供更精确的控制准则，它知道这些接口应该如何去构建。
+ 接口文件可以提供更结构化和组织化的管理。
+ SWIG不能解释出现在头文件中的某些定义。使用独立的文件允许你将这些问题隔离开来。
+ 接口文件对提供什么样的接口提供更精确的控制。像扩展系统的用户能查看接口文件，并且立刻了解哪些功能是可用的，而不需要再深入到原始头文件中去了。